# -*- coding: utf-8 -*-
"""CA1_delvin_vallooran_jose_20039903.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zlo3kDB-jbALZGdql8-Q9ipWrn0sV7Rt

#scraping data using json
"""

#importing files
import requests
import json
import pandas as pd

#importing url from site
url = 'https://api.openweathermap.org/data/2.5/onecall?lat=51.5085&lon=-0.1257&units=metric&appid=5796abbde9106b7da4febfae8c44c232'

#getting source from payload
data={"occupancy"}

#getting header from headers
header={'accept':'*/*',
'accept-encoding':'gzip, deflate',
'accept-language':'en-IN,en;q=0.9,ml-IN;q=0.8,ml;q=0.7,en-GB;q=0.6,en-US;q=0.5',
'connection':'keep-alive',
'dnt':'1',
'host':'api.openweathermap.org',
'origin':'https://openweathermap.org',
'referer':'https://openweathermap.org/',
'sec-ch-ua':'"Chromium";v="130", "Google Chrome";v="130", "Not?A_Brand";v="99"',
'sec-ch-ua-mobile':'?0',
'sec-ch-ua-platform':'"Windows"',
'sec-fetch-dest':'empty',
'sec-fetch-mode':'cors',
'sec-fetch-site':'same-site',
'user-agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36'}

#sending http post request
r=requests.post(url,headers=header,data=data)

#checking response is it 200 or not
r

#checking content of site
r.content

#converting raw to json file
j=json.loads(r.content)

#get keys from the dictionary j
j.keys()

"""##getting data"""

#data of latitude
data_lat=j['lat']
data_lat

#data of longitude
data_lon=j['lon']
data_lon

#data of timezone
data_timezone=j['timezone']
data_timezone

#data of current hour(didnt take not enough rows)
data_current=pd.json_normalize(j['current'])

#data of minutes for one hour (didnt take not enough columns)
data_min=pd.json_normalize(j['minutely'])

#data of hourly for 48 hour
data_hourly=pd.json_normalize(j['hourly'])

#data of daily for 7 days
data_daily=pd.json_normalize(j['daily'])

"""#feature engineering

#hourly data
"""

data_hourly.head()

"""changing date time"""

data_hourly['dt']=pd.to_datetime(data_hourly['dt'],unit='s')#converting values in dt column to datetime
data_hourly['date'] = data_hourly['dt'].dt.date #datetime seperated into date
data_hourly['time'] = data_hourly['dt'].dt.time#datatime seperated into time
# data_hourly.drop(columns=['dt'],inplace=True)#dropped dt column

data_hourly.head()

"""seperating weather column to different columns"""

#used explode to seperate list of dictionaries
data_hourly_weather=pd.json_normalize(data_hourly['weather'].explode())
data_hourly.drop(columns=['weather'],inplace=True)
data_hourly=data_hourly.join(data_hourly_weather)

data_hourly.head()

"""rearranging the columns and automattically add columns if any extra comes up"""

column_order = [
    'id','dt' , 'icon', 'temp', 'feels_like', 'pressure',
    'humidity', 'dew_point', 'uvi', 'clouds', 'visibility', 'wind_speed', 'wind_deg',
    'wind_gust', 'pop', 'rain.1h', 'description', 'main'
]

#runs the program for extra column comes up with null value to written zero
for col in column_order:
    if col not in data_hourly.columns:
        data_hourly[col] = 0

#code adds up if any extra column shows up
data_hourly = data_hourly[column_order+[col for col in data_hourly if col not in column_order]]

data_hourly.head()

"""spliting description into two columns"""

data_hourly['description'].unique()

data_hourly['main'].unique()

"""new column with condition and weather"""

#spliting description column values to two different columns condition and weather
data_hourly[['condition','weather']]=data_hourly['description'].str.split(' ',n=1,expand=True)

data_hourly.drop(columns=['main','description','id'],inplace=True)#dropping unwanted columns

data_hourly.head()

"""#removing null value

removing null for temp,feels_like,pressure,humidity,dew_point,uvi,clouds,visibility,wind_speed,wind_deg,pop using mean
"""

import seaborn as sns
import matplotlib.pyplot as plt

columns_to_check = ['temp', 'feels_like', 'pressure', 'humidity', 'dew_point', 'uvi', 'clouds', 'visibility', 'wind_speed', 'wind_deg', 'pop','wind_gust']
plt.figure(figsize=(15, 10))
for i, column in enumerate(columns_to_check, 1):
    plt.subplot(4, 3, i)
    sns.boxplot(y=data_hourly[column])
    plt.title(f'Boxplot of {column}')

plt.tight_layout()
plt.show()

#for taking the mean of  above and below value to fill  the null value
#reference from chatgpt
for i in columns_to_check:
    col_values = data_hourly[i].values
    initial_window = 2

    for j in range(len(col_values)):
        if pd.isna(col_values[j]):
            window = initial_window
            mean_value = None

            while True:
                start = max(0, j - window)
                end = min(len(col_values), j + window + 1)
                surrounding_values = col_values[start:end]
                valid_values = [v for v in surrounding_values if not pd.isna(v)]

                if valid_values:
                    mean_value = np.mean(valid_values)
                    col_values[j] = mean_value
                    break
                window += 1

    data_hourly[i] = col_values

data_hourly.head()

"""removing null for icon, condition ,weather using mode"""

#work same as above code but it will take mode
columns_mode=['icon','condition','weather']

for i in columns_mode:
    col_values = data_hourly[i].values
    initial_window = 2

    for j in range(len(col_values)):
        if pd.isna(col_values[j]):
            window = initial_window
            mode_value = None

            while True:
                start = max(0, j - window)
                end = min(len(col_values), j + window + 1)
                surrounding_values = col_values[start:end]
                valid_values = [v for v in surrounding_values if not pd.isna(v)]

                if valid_values:
                    mode_value = pd.Series(valid_values).mode()
                    if len(mode_value) == 1:
                        col_values[j] = mode_value.iloc[0]
                        break
                window += 1

    data_hourly[i] = col_values

data_hourly.head()

"""removin for rain.1h"""

data_hourly['rain.1h'].fillna(0,inplace=True)

"""removing if any addition columns comes up"""

data_hourly.fillna(0,inplace=True)

"""checking null values"""

data_hourly.isnull().sum()

data_hourly

"""adding extra columns"""

#adding categorical values using the numerical values in data
import pandas as pd
import numpy as np

def classify_column(column_values, low_threshold, high_threshold, low_label, high_label, medium_label):
    return np.where(column_values < low_threshold, low_label,
                    np.where(column_values > high_threshold, high_label, medium_label))

def classify_weather_data(df):
    # Define the thresholds and labels for classification
    thresholds = {
        'temp': {'low': 5, 'high': 15, 'labels': ['Cold', 'Warm', 'Mild']},
        'feels_like': {'low': 5, 'high': 15, 'labels': ['Chilly', 'Hot', 'Comfortable']},
        'pressure': {'low': 1000, 'high': 1020, 'labels': ['Low Pressure', 'Normal Pressure', 'High Pressure']},
        'humidity': {'low': 40, 'high': 70, 'labels': ['Dry', 'Humid', 'Moderate']},
        'dew_point': {'low': 5, 'high': 10, 'labels': ['Dry', 'Moist', 'Comfortable']},
        'uvi': {'low': 0, 'high': 5, 'labels': ['Safe', 'Strong', 'Extreme']},
        'clouds': {'low': 20, 'high': 60, 'labels': ['Clear', 'Partly Cloudy', 'Cloudy']},
        'visibility': {'low': 5, 'high': 10, 'labels': ['Clear', 'Good', 'Fair']},
        'wind_speed': {'low': 15, 'high': 30, 'labels': ['Calm', 'Windy', 'Breezy']},
        'wind_deg': {'low': 0, 'high': 360, 'labels': ['Low', 'Moderate', 'High']},
        'wind_gust': {'low': 20, 'high': 50, 'labels': ['Gentle', 'Strong', 'Very Strong']},
        'pop': {'low': 20, 'high': 50, 'labels': ['Unlikely', 'Likely', 'Very Likely']},
    }

    for col in thresholds.keys():
        low_threshold = thresholds[col]['low']
        high_threshold = thresholds[col]['high']
        low_label, medium_label, high_label = thresholds[col]['labels']

        # Apply the classification function and create new columns with the classification
        df[f'{col}_classification'] = classify_column(df[col], low_threshold, high_threshold, low_label, medium_label, high_label)

    return df

classified_data = classify_weather_data(data_hourly)

data_hourly.info()

#again rearranging the columns for classification
column_order = [
    'date','time','icon', 'temp','temp_classification','feels_like','feels_like_classification', 'pressure','pressure_classification',
    'humidity','humidity_classification', 'dew_point','dew_point_classification', 'uvi','uvi_classification', 'clouds','clouds_classification', 'visibility','visibility_classification', 'wind_speed','wind_speed_classification', 'wind_deg','wind_deg_classification',
    'wind_gust','wind_gust_classification', 'pop','pop_classification' ,'rain.1h'
]

#runs the program for extra column comes up with null value to written zero
for col in column_order:
    if col not in data_hourly.columns:
        data_hourly[col] = 0

#code adds up if any extra column shows up
data_hourly = data_hourly[column_order+[col for col in data_hourly if col not in column_order]]

data_hourly.head()

data_hourly.info()

#renamed rain.1h to rain
data_hourly.rename(columns={"rain.1h":"rain"},inplace=True)

data_hourly.fillna(0,inplace=True)

data_hourly.info()

data_hourly.head()

data_hourly['visibility']

data_hourly.isnull().sum()

data_hourly.info()

# data_hourly.drop(columns=['dt'],inplace=True)

data_hourly.info()

"""#daily data"""

data_daily.head()

data_daily.info()

data_daily['dt']=pd.to_datetime(data_daily['dt'],unit='s')#changing to datetime
data_daily['date'] = data_daily['dt'].dt.date #datetime seperated into date
data_daily['time'] = data_daily['dt'].dt.time#datatime seperated into time
# data_daily.drop(columns=['datetime'],inplace=True)#dropping dt
data_daily['date']=data_daily['date'].astype(str)#converting to string
data_daily['time']=data_daily['time'].astype(str)#converting to string

data_daily.head()

"""for sunrise"""

data_daily['sunrise']=pd.to_datetime(data_daily['sunrise'],unit='s')
data_daily['sunrise_date'] = data_daily['sunrise'].dt.date
data_daily['sunrise_time'] = data_daily['sunrise'].dt.time
data_daily.drop(columns=['sunrise'],inplace=True)
data_daily['sunrise_date']=data_daily['sunrise_date'].astype(str)
data_daily['sunrise_time']=data_daily['sunrise_time'].astype(str)
data_daily.drop(columns=['sunrise_date'],inplace=True)

"""for sunset"""

data_daily['sunset']=pd.to_datetime(data_daily['sunset'],unit='s')
data_daily['sunset_date'] = data_daily['sunset'].dt.date
data_daily['sunset_time'] = data_daily['sunset'].dt.time
data_daily.drop(columns=['sunset'],inplace=True)
data_daily['sunset_date']=data_daily['sunset_date'].astype(str)
data_daily['sunset_time']=data_daily['sunset_time'].astype(str)
data_daily.drop(columns=['sunset_date'],inplace=True)

"""for moonrise"""

data_daily['moonrise']=pd.to_datetime(data_daily['moonrise'],unit='s')
data_daily['moonrise_date'] = data_daily['moonrise'].dt.date
data_daily['moonrise_time'] = data_daily['moonrise'].dt.time
data_daily.drop(columns=['moonrise'],inplace=True)
data_daily['moonrise_date']=data_daily['moonrise_date'].astype(str)
data_daily['moonrise_time']=data_daily['moonrise_time'].astype(str)
data_daily.drop(columns=['moonrise_date'],inplace=True)

"""for moonset"""

data_daily['moonset']=pd.to_datetime(data_daily['moonset'],unit='s')
data_daily['moonset_date'] = data_daily['moonset'].dt.date
data_daily['moonset_time'] = data_daily['moonset'].dt.time
data_daily.drop(columns=['moonset'],inplace=True)
data_daily['moonset_date']=data_daily['moonset_date'].astype(str)
data_daily['moonset_time']=data_daily['moonset_time'].astype(str)
data_daily.drop(columns=['moonset_date'],inplace=True)

"""splitting weather"""

#seperating weather column
data_daily_weather=pd.json_normalize(data_daily['weather'].explode())
data_daily.drop(columns=['weather'],inplace=True)#dropping weather
data_daily=data_daily.join(data_daily_weather)

"""arranging columns"""

data_daily.info()

"""rearranging the data"""

column_order_daily = ['dt','id','date','time','sunrise_time','sunset_time','moonrise_time','moonset_time','moon_phase', 'icon','pressure', 'humidity', 'dew_point',
                      'wind_speed', 'wind_deg', 'wind_gust', 'clouds', 'pop', 'rain', 'uvi','temp.day','temp.min','temp.max','temp.night','temp.eve','temp.morn',
                      'feels_like.day','feels_like.night','feels_like.eve','feels_like.morn', 'description', 'main']
#runs the program for extra column comes up with null value to written zero
for col in column_order_daily:
    if col not in data_daily.columns:
        data_daily[col] = 0

#code adds up if any extra column shows up
data_daily = data_daily[column_order_daily+[col for col in data_daily if col not in column_order_daily]]

data_daily.head()

"""seperating description to two columns condition and weather for simpler data"""

data_daily[['condition','weather']]=data_daily['description'].str.split(' ',n=1,expand=True)
data_daily.drop(columns=['main','description','id'],inplace=True)#dropping unwanted columns

data_daily.head()

data_daily.info()

"""removing  null values"""

import pandas as pd
import numpy as np
def classify_column(column_values, low_threshold, high_threshold, low_label, high_label, medium_label):
    return np.where(column_values < low_threshold, low_label,
                    np.where(column_values > high_threshold, high_label, medium_label))

def classify_weather_data(df):
    thresholds = {
        'temp': {'low': 5, 'high': 15, 'labels': ['Cold', 'Warm', 'Mild']},
        'feels_like': {'low': 5, 'high': 15, 'labels': ['Chilly', 'Hot', 'Comfortable']},
        'pressure': {'low': 1000, 'high': 1020, 'labels': ['Low Pressure', 'Normal Pressure', 'High Pressure']},
        'humidity': {'low': 40, 'high': 70, 'labels': ['Dry', 'Humid', 'Moderate']},
        'dew_point': {'low': 5, 'high': 10, 'labels': ['Dry', 'Moist', 'Comfortable']},
        'uvi': {'low': 0, 'high': 5, 'labels': ['Safe', 'Strong', 'Extreme']},
        'clouds': {'low': 20, 'high': 60, 'labels': ['Clear', 'Partly Cloudy', 'Cloudy']},
        'visibility': {'low': 5, 'high': 10, 'labels': ['Clear', 'Good', 'Fair']},
        'wind_speed': {'low': 15, 'high': 30, 'labels': ['Calm', 'Windy', 'Breezy']},
        'wind_deg': {'low': 0, 'high': 360, 'labels': ['Low', 'Moderate', 'High']},
        'wind_gust': {'low': 20, 'high': 50, 'labels': ['Gentle', 'Strong', 'Very Strong']},
        'pop': {'low': 20, 'high': 50, 'labels': ['Unlikely', 'Likely', 'Very Likely']},
        # 'moon_phase': {'low': 0.25, 'high': 0.75, 'labels': ['New Moon', 'Full Moon', 'Waxing/Waning']},
        'temp.day': {'low': 5, 'high': 15, 'labels': ['Cold Day', 'Hot Day', 'Mild Day']},
        'temp.min': {'low': 0, 'high': 10, 'labels': ['Freezing', 'Warm', 'Cool']},
        'temp.max': {'low': 10, 'high': 20, 'labels': ['Cool', 'Hot', 'Warm']},
        'temp.night': {'low': 5, 'high': 15, 'labels': ['Cold Night', 'Warm Night', 'Mild Night']},
        'temp.eve': {'low': 5, 'high': 15, 'labels': ['Chilly Evening', 'Warm Evening', 'Pleasant Evening']},
        'temp.morn': {'low': 5, 'high': 15, 'labels': ['Chilly Morning', 'Warm Morning', 'Pleasant Morning']},
        'feels_like.day': {'low': 5, 'high': 15, 'labels': ['Cold Feel', 'Hot Feel', 'Mild Feel']},
        'feels_like.night': {'low': 5, 'high': 15, 'labels': ['Cold Feel', 'Warm Feel', 'Mild Feel']},
        'feels_like.eve': {'low': 5, 'high': 15, 'labels': ['Cold Feel', 'Warm Feel', 'Mild Feel']},
        'feels_like.morn': {'low': 5, 'high': 15, 'labels': ['Cold Feel', 'Warm Feel', 'Mild Feel']},
    }

    for col in thresholds.keys():
      if col in data_daily.columns:
        low_threshold = thresholds[col]['low']
        high_threshold = thresholds[col]['high']
        low_label, medium_label, high_label = thresholds[col]['labels']


        data_daily[f'{col}_classification'] = classify_column(df[col], low_threshold, high_threshold, low_label, medium_label, high_label)

    return data_daily


classified_data = classify_weather_data(data_daily)

def classify_moon_phase(moon_phase):
    if moon_phase < 0.25:
        return 'New Moon'
    elif moon_phase < 0.5:
        return 'First Quarter'
    elif moon_phase > 0.75:
        return 'Full Moon'
    else:
        return 'Last Quarter'

data_daily['moon_phase_classification'] = data_daily['moon_phase'].apply(classify_moon_phase)

data_daily.head()

column_order_daily = ['dt','date','time','sunrise_time','sunset_time','moonrise_time','moonset_time','moon_phase','moon_phase_classification', 'icon','pressure','pressure_classification', 'humidity','humidity_classification', 'dew_point','dew_point_classification',
                      'wind_speed','wind_speed_classification', 'wind_deg','wind_deg_classification', 'wind_gust','wind_gust_classification', 'clouds','clouds_classification', 'pop','pop_classification', 'uvi','uvi_classification','temp.day','temp.day_classification','temp.min','temp.min_classification','temp.max','temp.max_classification','temp.night','temp.night_classification', 'temp.eve','temp.eve_classification', 'temp.morn','temp.morn_classification',
                      'feels_like.day' ,'feels_like.day_classification','feels_like.night','feels_like.night_classification','feels_like.eve','feels_like.eve_classification','feels_like.morn','feels_like.morn_classification', 'rain',]
#runs the program for extra column comes up with null value to written zero
for col in column_order_daily:
    if col not in data_daily.columns:
        data_daily[col] = 0

#code adds up if any extra column shows up
data_daily = data_daily[column_order_daily+[col for col in data_daily if col not in column_order_daily]]

data_daily.info()

data_daily['moon_phase']

data_daily['moon_phase_classification']

data_daily.head()

#taken first two rows
data_daily=data_daily.iloc[:2]

data_daily

data_hourly['dt']=pd.to_datetime(data_hourly['dt'],unit='s')
data_daily['dt']=pd.to_datetime(data_daily['dt'],unit='s')

#to fill the null value of daily data by taking the mean of the hourly data if any comes up
#referred chatgpt
for index,row in data_daily.iterrows():
    for col in ['pressure', 'humidity', 'dew_point', 'uvi', 'clouds', 'wind_speed', 'wind_deg', 'wind_gust', 'pop']:
      if pd.isna(row[col]):
        day_start=row['dt'].replace(hour=0,minute=0,second=0)
        day_end=day_start+pd.Timedelta(days=1)
        data_hourly_day=data_hourly[(data_hourly['dt']>=day_start)&(data_hourly['dt']<day_end)]

        if not data_hourly_day.empty:
          mean_value=data_hourly_day[col].mean()
          data_daily.at[index,col]=mean_value

#to fill null value of categorical values by taking the mode from hourly data
for index,row in data_daily.iterrows():
  for col in ['icon', 'condition', 'weather','rain']:
    if pd.isna(row[col]):
      day_start=row['dt'].replace(hour=0,minute=0,second=0)
      day_end=day_start+pd.Timedelta(days=1)
      data_hourly_day=data_hourly[(data_hourly['dt']>=day_start)&(data_hourly['dt']<day_end)]

      if not data_hourly_day.empty:
        mode_value=data_hourly_day[col].mode()
        if not mode_value.empty:
          data_daily.at[index,col]=mode_value.iloc[0]

#to fill the null values of temp.max and min by taking min and max value of hourly data
column_mapping={
    'temp.max':'temp',
    'temp.min':'temp'
}
for index, row in data_daily.iterrows():
    for col, new_col in column_mapping.items():
      if pd.isna(row[col]):
        day_start=row['dt'].replace(hour=0,minute=0,second=0)
        day_end=day_start+pd.Timedelta(days=1)
        data_hourly_day=data_hourly[(data_hourly['dt']>=day_start)&(data_hourly['dt']<day_end)]

        if not data_hourly_day.empty:
          if col=='temp.max':
            data_daily.at[index,col]=data_hourly_day['temp'].max()
          elif col=='temp.min':
            data_daily.at[index,new_col]=data_hourly_day['temp'].min()

#to fill the null values of temp and feels like in different times of day
#referred chatgpt
def classify_time_of_day(timestamp):
    hour = timestamp.hour
    if 6 <= hour < 12:
        return 'Morning'
    elif 12 <= hour < 18:
        return 'Afternoon'
    elif 18 <= hour < 22:
        return 'Evening'
    else:
        return 'Night'

column_mapping_time = {
    'temp.day': 'temp',
    'temp.night': 'temp',
    'temp.eve': 'temp',
    'temp.morn': 'temp',
    'feels_like.day': 'feels_like',
    'feels_like.night': 'feels_like',
    'feels_like.eve': 'feels_like',
    'feels_like.morn': 'feels_like'
}

for index, row in data_daily.iterrows():
    for col, new_col in column_mapping_time.items():
        if pd.isna(row[col]):  # If the value is missing
            day_start = row['dt'].replace(hour=0, minute=0, second=0)
            day_end = day_start + pd.Timedelta(days=1)
            data_hourly_day = data_hourly[(data_hourly['dt'] >= day_start) & (data_hourly['dt'] < day_end)]

            if not data_hourly_day.empty:
                # Loop over each time of day and assign mean values to the corresponding columns
                for time_of_day in ['Morning', 'Afternoon', 'Evening', 'Night']:
                    data_hourly_day_time = data_hourly_day[data_hourly_day['dt'].apply(lambda ts: classify_time_of_day(ts) == time_of_day)]

                    if not data_hourly_day_time.empty:
                        # Compute the mean for the relevant time of day
                        if col in ['temp.day', 'temp.night', 'temp.eve', 'temp.morn']:
                            if time_of_day == 'Morning':
                                data_daily.at[index, col] = data_hourly_day_time['temp'].mean()
                            elif time_of_day == 'Afternoon':
                                data_daily.at[index, col] = data_hourly_day_time['temp'].mean()
                            elif time_of_day == 'Evening':
                                data_daily.at[index, col] = data_hourly_day_time['temp'].mean()
                            elif time_of_day == 'Night':
                                data_daily.at[index, col] = data_hourly_day_time['temp'].mean()

                        if col in ['feels_like.day', 'feels_like.night', 'feels_like.eve', 'feels_like.morn']:
                            if time_of_day == 'Morning':
                                data_daily.at[index, col] = data_hourly_day_time['feels_like'].mean()
                            elif time_of_day == 'Afternoon':
                                data_daily.at[index, col] = data_hourly_day_time['feels_like'].mean()
                            elif time_of_day == 'Evening':
                                data_daily.at[index, col] = data_hourly_day_time['feels_like'].mean()
                            elif time_of_day == 'Night':
                                data_daily.at[index, col] = data_hourly_day_time['feels_like'].mean()

data_daily.head()

data_daily

data_daily.info()

data_daily.isnull().sum()

#adding visibility of different times in a day
from datetime import timedelta

data_daily['visibility_morning'] = None
data_daily['visibility_afternoon'] = None
data_daily['visibility_evening'] = None
data_daily['visibility_night'] = None

data_hourly['time_of_day'] = data_hourly['dt'].apply(classify_time_of_day)

for index, row in data_daily.iterrows():
    day_start = row['dt'].replace(hour=0, minute=0, second=0)
    day_end = day_start + timedelta(days=1)

    data_hourly_day = data_hourly[(data_hourly['dt'] >= day_start) & (data_hourly['dt'] < day_end)]

    if not data_hourly_day.empty:
        visibility_means = data_hourly_day.groupby('time_of_day')['visibility'].mean()
        if 'Morning' in visibility_means:
            data_daily.at[index, 'visibility_morning'] = visibility_means['Morning']
        if 'Afternoon' in visibility_means:
            data_daily.at[index, 'visibility_afternoon'] = visibility_means['Afternoon']
        if 'Evening' in visibility_means:
            data_daily.at[index, 'visibility_evening'] = visibility_means['Evening']
        if 'Night' in visibility_means:
            data_daily.at[index, 'visibility_night'] = visibility_means['Night']

data_daily.head()

visibility_thresholds = {
    'visibility_morning': {'low': 1000, 'high': 1500, 'labels': ['Low Visibility', 'Moderate Visibility', 'High Visibility']},
    'visibility_afternoon': {'low': 1000, 'high': 1500, 'labels': ['Low Visibility', 'Moderate Visibility', 'High Visibility']},
    'visibility_evening': {'low': 1000, 'high': 1500, 'labels': ['Low Visibility', 'Moderate Visibility', 'High Visibility']},
    'visibility_night': {'low': 1000, 'high': 1500, 'labels': ['Low Visibility', 'Moderate Visibility', 'High Visibility']}
}

time_of_day_columns = ['visibility_morning', 'visibility_afternoon', 'visibility_evening', 'visibility_night']
for column in time_of_day_columns:
    if column not in data_daily.columns:
        data_daily[column] = None

for time_of_day, params in visibility_thresholds.items():
    if time_of_day in data_daily.columns:
        low_threshold = params['low']
        high_threshold = params['high']
        low_label, medium_label, high_label = params['labels']

        data_daily[f'{time_of_day}_classification'] = np.where(
            data_daily[time_of_day] < low_threshold, low_label,
            np.where(
                data_daily[time_of_day] > high_threshold, high_label,
                medium_label
            )
        )

data_daily.head()

data_daily.isnull().sum()

column_order_daily = ['dt','date','time','sunrise_time','sunset_time','moonrise_time','moonset_time','moon_phase','moon_phase_classification', 'icon','pressure','pressure_classification', 'humidity','humidity_classification', 'dew_point','dew_point_classification',
                      'wind_speed','wind_speed_classification', 'wind_deg','wind_deg_classification', 'wind_gust','wind_gust_classification', 'clouds','clouds_classification', 'pop','pop_classification', 'uvi','uvi_classification','temp.day','temp.day_classification','temp.min','temp.min_classification','temp.max','temp.max_classification','temp.night','temp.night_classification', 'temp.eve','temp.eve_classification', 'temp.morn','temp.morn_classification',
                      'feels_like.day' ,'feels_like.day_classification','feels_like.night','feels_like.night_classification','feels_like.eve','feels_like.eve_classification','feels_like.morn','feels_like.morn_classification','visibility_morning','visibility_morning_classification','visibility_afternoon','visibility_afternoon_classification','visibility_evening','visibility_evening_classification','visibility_night','visibility_night_classification', 'rain','condition','weather']
#runs the program for extra column comes up with null value to written zero
for col in column_order_daily:
    if col not in data_daily.columns:
        data_daily[col] = 0

#code adds up if any extra column shows up
data_daily = data_daily[column_order_daily+[col for col in data_daily if col not in column_order_daily]]

data_daily.info()

data_daily.drop(columns=['dt'],inplace=True)

data_daily.info()

data_hourly.drop(columns=['dt'],inplace=True)

data_hourly.info()

# data_daily['date'] = data_daily['date'].astype(str)
data_hourly['date'] = data_hourly['date'].astype(str)
data_hourly['time'] = data_hourly['time'].astype(str)

"""#pushing data to mongo"""

!pip install "pymongo[srv]"
!pip install pymongo
import pymongo
from pymongo.mongo_client import MongoClient
from pymongo.server_api import ServerApi

client=pymongo.MongoClient("mongodb+srv://20039903:UhcTl17Md55P3T2q@delvin.mqyx1.mongodb.net/?retryWrites=true&w=majority&appName=delvin")
db=client["delvin"]

db["data_daily"].insert_many(data_daily.to_dict(orient='records'))
db["data_hourly"].insert_many(data_hourly.to_dict(orient='records'))

print(client.list_database_names())

daily_data_sample = list(db["daily_data"].find().limit(5))
print("Sample Data from 'daily_data' Collection:")
for record in daily_data_sample:
    print(record)

hourly_data_sample = list(db["data_hourly"].find().limit(5))
print("\nSample Data from 'data_hourly' Collection:")
for record in hourly_data_sample:
    print(record)

daily_data_count = db["daily_data"].count_documents({})
hourly_data_count = db["data_hourly"].count_documents({})
print(f"\nTotal Records in 'daily_data' Collection: {daily_data_count}")
print(f"Total Records in 'data_hourly' Collection: {hourly_data_count}")

"""#two day updation"""

import requests
import pandas as pd
import numpy as np
import time
from datetime import datetime,timedelta
import pymongo
from pymongo import MongoClient


def connect_to_mogodb():
    client=pymongo.MongoClient("mongodb+srv://20039903:UhcTl17Md55P3T2q@delvin.mqyx1.mongodb.net/?retryWrites=true&w=majority&appName=delvin")
    db=client["delvin"]
    hourly_collection=db["hourly_data"]
    daily_collection=db["daily_data"]
    return hourly_collection,daily_collection

def scraping_hourly_data():
    # Importing URL from site
    url = 'https://api.openweathermap.org/data/2.5/onecall?lat=51.5085&lon=-0.1257&units=metric&appid=5796abbde9106b7da4febfae8c44c232'

    # Getting source from payload
    data = {"occupancy"}

    # Getting header from headers
    header = {
        'accept': '*/*',
        'accept-encoding': 'gzip, deflate',
        'accept-language': 'en-IN,en;q=0.9,ml-IN;q=0.8,ml;q=0.7,en-GB;q=0.6,en-US;q=0.5',
        'connection': 'keep-alive',
        'dnt': '1',
        'host': 'api.openweathermap.org',
        'origin': 'https://openweathermap.org',
        'referer': 'https://openweathermap.org/',
        'sec-ch-ua': '"Chromium";v="130", "Google Chrome";v="130", "Not?A_Brand";v="99"',
        'sec-ch-ua-mobile': '?0',
        'sec-ch-ua-platform': '"Windows"',
        'sec-fetch-dest': 'empty',
        'sec-fetch-mode': 'cors',
        'sec-fetch-site': 'same-site',
        'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36'
    }

    # Sending HTTP POST request
    r = requests.post(url, headers=header, data=data)
    j = r.json()

    # Extracting hourly data
    hourly_data = pd.json_normalize(j['hourly'])
    hourly_data['dt'] = pd.to_datetime(hourly_data['dt'], unit='s')
    hourly_data['date'] = hourly_data['dt'].dt.date
    hourly_data['time'] = hourly_data['dt'].dt.time
    hourly_data['date'] = hourly_data['date'].astype(str)
    hourly_data['time'] = hourly_data['time'].astype(str)
    # hourly_data['full_timestamp'] = hourly_data['full_timestamp'].astype(str)


    # Normalizing weather data
    data_hourly_weather = pd.json_normalize(hourly_data['weather'].explode())
    hourly_data.drop(columns=['weather'], inplace=True)
    hourly_data = hourly_data.join(data_hourly_weather)

    # Defining column order
    column_order = [
        'date','time','id', 'icon', 'temp', 'feels_like', 'pressure', 'humidity', 'dew_point',
        'uvi', 'clouds', 'visibility', 'wind_speed', 'wind_deg', 'wind_gust', 'pop',
        'rain.1h', 'description', 'main'
    ]

    # Adding extra columns with null values as zero
    for col in column_order:
        if col not in hourly_data.columns:
            hourly_data[col] = 0

    # Reordering columns
    hourly_data = hourly_data[column_order + [col for col in hourly_data if col not in column_order]]
    hourly_data[['condition', 'weather']] = hourly_data['description'].str.split(' ', n=1, expand=True)
    hourly_data.drop(columns=['main', 'description', 'id'], inplace=True)

    # Filling missing values in numerical columns
    columns_to_check = ['temp', 'feels_like', 'pressure', 'humidity', 'dew_point', 'uvi',
                        'clouds', 'visibility', 'wind_speed', 'wind_deg', 'wind_gust', 'pop', 'rain.1h']
    for col in columns_to_check:
        col_values = hourly_data[col].values
        initial_window = 2

        for j in range(len(col_values)):
            if pd.isna(col_values[j]):
                window = initial_window
                mean_value = None

                while True:
                    start = max(0, j - window)
                    end = min(len(col_values), j + window + 1)
                    surrounding_values = col_values[start:end]
                    valid_values = [v for v in surrounding_values if not pd.isna(v)]

                    if valid_values:
                        mean_value = np.mean(valid_values)
                        col_values[j] = mean_value
                        break
                    window += 1

        hourly_data[col] = col_values

    # Filling missing values in categorical columns
    columns_mode = ['icon', 'condition', 'weather']
    for col in columns_mode:
        col_values = hourly_data[col].values
        initial_window = 2

        for i in range(len(col_values)):
            if pd.isna(col_values[i]):
                window = initial_window
                mode_value = None

                while True:
                    start = max(0, i - window)
                    end = min(len(col_values), i + window + 1)
                    surrounding_values = col_values[start:end]
                    valid_values = [v for v in surrounding_values if not pd.isna(v)]

                    if valid_values:
                        mode_value = pd.Series(valid_values).mode()
                        if len(mode_value) == 1:
                            col_values[i] = mode_value.iloc[0]
                        break
                    window += 1

        hourly_data[col] = col_values

    # Filling specific column and overall missing values
    hourly_data['rain.1h'].fillna(0)

    # df.rename(columns={'rain.1h':'rain'},inplace=True)





    thresholds = {
             'temp': {'low': 5, 'high': 15, 'labels': ['Cold', 'Warm', 'Mild']},
             'feels_like': {'low': 5, 'high': 15, 'labels': ['Chilly', 'Hot', 'Comfortable']},
             'pressure': {'low': 1000, 'high': 1020, 'labels': ['Low Pressure', 'Normal Pressure', 'High Pressure']},
             'humidity': {'low': 40, 'high': 70, 'labels': ['Dry', 'Humid', 'Moderate']},
             'dew_point': {'low': 5, 'high': 10, 'labels': ['Dry', 'Moist', 'Comfortable']},
             'uvi': {'low': 0, 'high': 5, 'labels': ['Safe', 'Strong', 'Extreme']},
             'clouds': {'low': 20, 'high': 60, 'labels': ['Clear', 'Partly Cloudy', 'Cloudy']},
             'visibility': {'low': 5, 'high': 10, 'labels': ['Clear', 'Good', 'Fair']},
             'wind_speed': {'low': 15, 'high': 30, 'labels': ['Calm', 'Windy', 'Breezy']},
             'wind_deg': {'low': 0, 'high': 360, 'labels': ['Low', 'Moderate', 'High']},
             'wind_gust': {'low': 20, 'high': 50, 'labels': ['Gentle', 'Strong', 'Very Strong']},
             'pop': {'low': 20, 'high': 50, 'labels': ['Unlikely', 'Likely', 'Very Likely']},
        }

    for col,params in thresholds.items():
            low_threshold = params['low']
            high_threshold = params['high']
            low_label, medium_label, high_label = params['labels']

        # Apply the classification function and create new columns with the classification
            hourly_data[f'{col}_classification'] = np.where(
                hourly_data[col]<low_threshold,low_label,
                np.where(hourly_data[col]>high_threshold,high_label,medium_label)
            )

    #again rearranging the columns for classification
    column_order = [
       'date','time','icon', 'temp','temp_classification','feels_like','feels_like_classification', 'pressure','pressure_classification',
       'humidity','humidity_classification', 'dew_point','dew_point_classification', 'uvi','uvi_classification', 'clouds','clouds_classification', 'visibility','visibility_classification', 'wind_speed','wind_speed_classification', 'wind_deg','wind_deg_classification',
       'wind_gust','wind_gust_classification', 'pop','pop_classification' ,'rain.1h'
      ]

#runs the program for extra column comes up with null value to written zero
    for col in column_order:
        if col not in hourly_data.columns:
            hourly_data[col] = 0

#code adds up if any extra column shows up
    hourly_data = hourly_data[column_order+[col for col in hourly_data if col not in column_order]]


    # classified_data = classify_weather_data(hourly_data)
    # hourly_data1.drop(columns=['dt'],inplace=True)

    # return hourly_data1,hourly_data
    hourly_data.fillna(0,inplace=True)
    return hourly_data


def scraping_daily_data(hourly_data):
    # Importing URL from site
    url = 'https://api.openweathermap.org/data/2.5/onecall?lat=51.5085&lon=-0.1257&units=metric&appid=5796abbde9106b7da4febfae8c44c232'

    # Getting source from payload
    data = {"occupancy"}

    # Getting header from headers
    header = {
        'accept': '*/*',
        'accept-encoding': 'gzip, deflate',
        'accept-language': 'en-IN,en;q=0.9,ml-IN;q=0.8,ml;q=0.7,en-GB;q=0.6,en-US;q=0.5',
        'connection': 'keep-alive',
        'dnt': '1',
        'host': 'api.openweathermap.org',
        'origin': 'https://openweathermap.org',
        'referer': 'https://openweathermap.org/',
        'sec-ch-ua': '"Chromium";v="130", "Google Chrome";v="130", "Not?A_Brand";v="99"',
        'sec-ch-ua-mobile': '?0',
        'sec-ch-ua-platform': '"Windows"',
        'sec-fetch-dest': 'empty',
        'sec-fetch-mode': 'cors',
        'sec-fetch-site': 'same-site',
        'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36'
    }

    # Sending HTTP POST request
    import pandas as pd

    r = requests.post(url, headers=header, data=data)
    j = r.json()
    data_daily = pd.json_normalize(j['daily'])

    data_daily['dt']=pd.to_datetime(data_daily['dt'],unit='s')#changing to datetime
    data_daily['date'] = data_daily['dt'].dt.date #datetime seperated into date
    data_daily['time'] = data_daily['dt'].dt.time#datatime seperated into time
    # data_daily.drop(columns=['dt'],inplace=True)#dropping dt
    data_daily['date']=data_daily['date'].astype(str)#converting to string
    data_daily['time']=data_daily['time'].astype(str)#converting to string

    data_daily['sunrise']=pd.to_datetime(data_daily['sunrise'],unit='s')
    data_daily['sunrise_date'] = data_daily['sunrise'].dt.date
    data_daily['sunrise_time'] = data_daily['sunrise'].dt.time
    data_daily.drop(columns=['sunrise'],inplace=True)
    data_daily['sunrise_date']=data_daily['sunrise_date'].astype(str)
    data_daily['sunrise_time']=data_daily['sunrise_time'].astype(str)
    data_daily.drop(columns=['sunrise_date'],inplace=True)

    data_daily['sunset']=pd.to_datetime(data_daily['sunset'],unit='s')
    data_daily['sunset_date'] = data_daily['sunset'].dt.date
    data_daily['sunset_time'] = data_daily['sunset'].dt.time
    data_daily.drop(columns=['sunset'],inplace=True)
    data_daily['sunset_date']=data_daily['sunset_date'].astype(str)
    data_daily['sunset_time']=data_daily['sunset_time'].astype(str)
    data_daily.drop(columns=['sunset_date'],inplace=True)

    data_daily['moonrise']=pd.to_datetime(data_daily['moonrise'],unit='s')
    data_daily['moonrise_date'] = data_daily['moonrise'].dt.date
    data_daily['moonrise_time'] = data_daily['moonrise'].dt.time
    data_daily.drop(columns=['moonrise'],inplace=True)
    data_daily['moonrise_date']=data_daily['moonrise_date'].astype(str)
    data_daily['moonrise_time']=data_daily['moonrise_time'].astype(str)
    data_daily.drop(columns=['moonrise_date'],inplace=True)

    data_daily['moonset']=pd.to_datetime(data_daily['moonset'],unit='s')
    data_daily['moonset_date'] = data_daily['moonset'].dt.date
    data_daily['moonset_time'] = data_daily['moonset'].dt.time
    data_daily.drop(columns=['moonset'],inplace=True)
    data_daily['moonset_date']=data_daily['moonset_date'].astype(str)
    data_daily['moonset_time']=data_daily['moonset_time'].astype(str)
    data_daily.drop(columns=['moonset_date'],inplace=True)

    data_daily_weather=pd.json_normalize(data_daily['weather'].explode())
    data_daily.drop(columns=['weather'],inplace=True)#dropping weather
    data_daily=data_daily.join(data_daily_weather)

    column_order_daily = ['id','date','time','sunrise_time','sunset_time','moonrise_time','moonset_time','moon_phase', 'icon','pressure', 'humidity', 'dew_point',
                      'wind_speed', 'wind_deg', 'wind_gust', 'clouds', 'pop', 'rain', 'uvi','temp.day','temp.min','temp.max','temp.night','temp.eve','temp.morn',
                      'feels_like.day','feels_like.night','feels_like.eve','feels_like.morn', 'description', 'main']
#runs the program for extra column comes up with null value to written zero
    for col in column_order_daily:
        if col not in data_daily.columns:
            data_daily[col] = 0

#code adds up if any extra column shows up
    data_daily = data_daily[column_order_daily+[col for col in data_daily if col not in column_order_daily]]

    data_daily[['condition','weather']]=data_daily['description'].str.split(' ',n=1,expand=True)
    data_daily.drop(columns=['main','description','id'],inplace=True)#dropping unwanted columns


    import pandas as pd
    import numpy as np
    def classify_column(column_values, low_threshold, high_threshold, low_label, high_label, medium_label):
        return np.where(column_values < low_threshold, low_label,
                        np.where(column_values > high_threshold, high_label, medium_label))

    def classify_weather_data(df):
        thresholds = {
             'temp': {'low': 5, 'high': 15, 'labels': ['Cold', 'Warm', 'Mild']},
             'feels_like': {'low': 5, 'high': 15, 'labels': ['Chilly', 'Hot', 'Comfortable']},
             'pressure': {'low': 1000, 'high': 1020, 'labels': ['Low Pressure', 'Normal Pressure', 'High Pressure']},
             'humidity': {'low': 40, 'high': 70, 'labels': ['Dry', 'Humid', 'Moderate']},
             'dew_point': {'low': 5, 'high': 10, 'labels': ['Dry', 'Moist', 'Comfortable']},
             'uvi': {'low': 0, 'high': 5, 'labels': ['Safe', 'Strong', 'Extreme']},
             'clouds': {'low': 20, 'high': 60, 'labels': ['Clear', 'Partly Cloudy', 'Cloudy']},
             'visibility': {'low': 5, 'high': 10, 'labels': ['Clear', 'Good', 'Fair']},
             'wind_speed': {'low': 15, 'high': 30, 'labels': ['Calm', 'Windy', 'Breezy']},
             'wind_deg': {'low': 0, 'high': 360, 'labels': ['Low', 'Moderate', 'High']},
             'wind_gust': {'low': 20, 'high': 50, 'labels': ['Gentle', 'Strong', 'Very Strong']},
             'pop': {'low': 20, 'high': 50, 'labels': ['Unlikely', 'Likely', 'Very Likely']},
             # 'moon_phase': {'low': 0.25, 'high': 0.75, 'labels': ['New Moon', 'Full Moon', 'Waxing/Waning']},
             'temp.day': {'low': 5, 'high': 15, 'labels': ['Cold Day', 'Hot Day', 'Mild Day']},
             'temp.min': {'low': 0, 'high': 10, 'labels': ['Freezing', 'Warm', 'Cool']},
             'temp.max': {'low': 10, 'high': 20, 'labels': ['Cool', 'Hot', 'Warm']},
             'temp.night': {'low': 5, 'high': 15, 'labels': ['Cold Night', 'Warm Night', 'Mild Night']},
             'temp.eve': {'low': 5, 'high': 15, 'labels': ['Chilly Evening', 'Warm Evening', 'Pleasant Evening']},
             'temp.morn': {'low': 5, 'high': 15, 'labels': ['Chilly Morning', 'Warm Morning', 'Pleasant Morning']},
             'feels_like.day': {'low': 5, 'high': 15, 'labels': ['Cold Feel', 'Hot Feel', 'Mild Feel']},
             'feels_like.night': {'low': 5, 'high': 15, 'labels': ['Cold Feel', 'Warm Feel', 'Mild Feel']},
             'feels_like.eve': {'low': 5, 'high': 15, 'labels': ['Cold Feel', 'Warm Feel', 'Mild Feel']},
             'feels_like.morn': {'low': 5, 'high': 15, 'labels': ['Cold Feel', 'Warm Feel', 'Mild Feel']},
        }

        for col in thresholds.keys():
            if col in data_daily.columns:
               low_threshold = thresholds[col]['low']
               high_threshold = thresholds[col]['high']
               low_label, medium_label, high_label = thresholds[col]['labels']


               df[f'{col}_classification'] = classify_column(df[col], low_threshold, high_threshold, low_label, medium_label, high_label)

        return df


    classified_data = classify_weather_data(data_daily)

    def classify_moon_phase(moon_phase):
        if moon_phase < 0.25:
            return 'New Moon'
        elif moon_phase < 0.5:
            return 'First Quarter'
        elif moon_phase > 0.75:
            return 'Full Moon'
        else:
            return 'Last Quarter'

    data_daily['moon_phase_classification'] = data_daily['moon_phase'].apply(classify_moon_phase)


    column_order_daily = ['dt','date','time','sunrise_time','sunset_time','moonrise_time','moonset_time','moon_phase','moon_phase_classification', 'icon','pressure','pressure_classification', 'humidity','humidity_classification', 'dew_point','dew_point_classification',
                      'wind_speed','wind_speed_classification', 'wind_deg','wind_deg_classification', 'wind_gust','wind_gust_classification', 'clouds','clouds_classification', 'pop','pop_classification', 'uvi','uvi_classification','temp.day','temp.day_classification','temp.min','temp.min_classification','temp.max','temp.max_classification','temp.night','temp.night_classification', 'temp.eve','temp.eve_classification', 'temp.morn','temp.morn_classification',
                      'feels_like.day' ,'feels_like.day_classification','feels_like.night','feels_like.night_classification','feels_like.eve','feels_like.eve_classification','feels_like.morn','feels_like.morn_classification', 'rain',]
    #runs the program for extra column comes up with null value to written zero
    for col in column_order_daily:
        if col not in data_daily.columns:
            data_daily[col] = 0

#code adds up if any extra column shows up
    data_daily = data_daily[column_order_daily+[col for col in data_daily if col not in column_order_daily]]



    data_daily=data_daily.iloc[:2]

    hourly_data['dt']=pd.to_datetime(hourly_data['dt'],unit='s')
    data_daily['dt']=pd.to_datetime(data_daily['dt'],unit='s')


    for index,row in data_daily.iterrows():
        for col in ['pressure', 'humidity', 'dew_point', 'uvi', 'clouds', 'wind_speed', 'wind_deg', 'wind_gust', 'pop']:
            if pd.isna(row[col]):
               day_start=row['dt'].replace(hour=0,minute=0,second=0)
               day_end=day_start+pd.Timedelta(days=1)
               data_hourly_day=hourly_data[(hourly_data['dt']>=day_start)&(hourly_data['dt']<day_end)]

               if not data_hourly_day.empty:
                  mean_value=data_hourly_day[col].mean()
                  data_daily.at[index,col]=mean_value


    for index,row in data_daily.iterrows():
        for col in ['icon', 'condition', 'weather']:
             if pd.isna(row[col]):
                day_start=row['dt'].replace(hour=0,minute=0,second=0)
                day_end=day_start+pd.Timedelta(days=1)
                data_hourly_day=hourly_data[(hourly_data['dt']>=day_start)&(hourly_data['dt']<day_end)]

                if not data_hourly_day.empty:
                   mode_value=data_hourly_day[col].mode()
                   if not mode_value.empty:
                      data_daily.at[index,col]=mode_value.iloc[0]


    column_mapping={
    'temp.max':'temp',
    'temp.min':'temp'
    }
    for index, row in data_daily.iterrows():
        for col, new_col in column_mapping.items():
            if pd.isna(row[col]):
               day_start=row['dt'].replace(hour=0,minute=0,second=0)
               day_end=day_start+pd.Timedelta(days=1)
               data_hourly_day=hourly_data[(hourly_data['dt']>=day_start)&(hourly_data['dt']<day_end)]

               if not data_hourly_day.empty:
                  if col=='temp.max':
                     data_daily.at[index,col]=data_hourly_day['temp'].max()
                  elif col=='temp.min':
                     data_daily.at[index,new_col]=data_hourly_day['temp'].min()

    def classify_time_of_day(timestamp):
        hour = timestamp.hour
        if 6 <= hour < 12:
            return 'Morning'
        elif 12 <= hour < 18:
            return 'Afternoon'
        elif 18 <= hour < 22:
            return 'Evening'
        else:
            return 'Night'

    column_mapping_time = {
         'temp.day': 'temp',
         'temp.night': 'temp',
         'temp.eve': 'temp',
         'temp.morn': 'temp',
         'feels_like.day': 'feels_like',
         'feels_like.night': 'feels_like',
         'feels_like.eve': 'feels_like',
         'feels_like.morn': 'feels_like'
    }

    for index, row in data_daily.iterrows():
        for col, new_col in column_mapping_time.items():
            if pd.isna(row[col]):  # If the value is missing
               day_start = row['dt'].replace(hour=0, minute=0, second=0)
               day_end = day_start + pd.Timedelta(days=1)
               data_hourly_day = hourly_data[(hourly_data['dt'] >= day_start) & (hourly_data['dt'] < day_end)]

               if not data_hourly_day.empty:
                # Loop over each time of day and assign mean values to the corresponding columns
                   for time_of_day in ['Morning', 'Afternoon', 'Evening', 'Night']:
                       data_hourly_day_time = data_hourly_day[data_hourly_day['dt'].apply(lambda ts: classify_time_of_day(ts) == time_of_day)]

                       if not data_hourly_day_time.empty:
                        # Compute the mean for the relevant time of day
                           if col in ['temp.day', 'temp.night', 'temp.eve', 'temp.morn']:
                              if time_of_day == 'Morning':
                                  data_daily.at[index, col] = data_hourly_day_time['temp'].mean()
                              elif time_of_day == 'Afternoon':
                                  data_daily.at[index, col] = data_hourly_day_time['temp'].mean()
                              elif time_of_day == 'Evening':
                                  data_daily.at[index, col] = data_hourly_day_time['temp'].mean()
                              elif time_of_day == 'Night':
                                   data_daily.at[index, col] = data_hourly_day_time['temp'].mean()

                           if col in ['feels_like.day', 'feels_like.night', 'feels_like.eve', 'feels_like.morn']:
                              if time_of_day == 'Morning':
                                 data_daily.at[index, col] = data_hourly_day_time['feels_like'].mean()
                              elif time_of_day == 'Afternoon':
                                  data_daily.at[index, col] = data_hourly_day_time['feels_like'].mean()
                              elif time_of_day == 'Evening':
                                  data_daily.at[index, col] = data_hourly_day_time['feels_like'].mean()
                              elif time_of_day == 'Night':
                                   data_daily.at[index, col] = data_hourly_day_time['feels_like'].mean()


    #adding visibility of different times in a day
    from datetime import timedelta

    data_daily['visibility_morning'] = None
    data_daily['visibility_afternoon'] = None
    data_daily['visibility_evening'] = None
    data_daily['visibility_night'] = None

    hourly_data['time_of_day'] = hourly_data['dt'].apply(classify_time_of_day)

    for index, row in data_daily.iterrows():
        day_start = row['dt'].replace(hour=0, minute=0, second=0)
        day_end = day_start + timedelta(days=1)

        data_hourly_day = hourly_data[(hourly_data['dt'] >= day_start) & (hourly_data['dt'] < day_end)]

        if not data_hourly_day.empty:
           visibility_means = data_hourly_day.groupby('time_of_day')['visibility'].mean()
           if 'Morning' in visibility_means:
               data_daily.at[index, 'visibility_morning'] = visibility_means['Morning']
           if 'Afternoon' in visibility_means:
               data_daily.at[index, 'visibility_afternoon'] = visibility_means['Afternoon']
           if 'Evening' in visibility_means:
               data_daily.at[index, 'visibility_evening'] = visibility_means['Evening']
           if 'Night' in visibility_means:
               data_daily.at[index, 'visibility_night'] = visibility_means['Night']


    visibility_thresholds = {
        'visibility_morning': {'low': 1000, 'high': 1500, 'labels': ['Low Visibility', 'Moderate Visibility', 'High Visibility']},
        'visibility_afternoon': {'low': 1000, 'high': 1500, 'labels': ['Low Visibility', 'Moderate Visibility', 'High Visibility']},
        'visibility_evening': {'low': 1000, 'high': 1500, 'labels': ['Low Visibility', 'Moderate Visibility', 'High Visibility']},
        'visibility_night': {'low': 1000, 'high': 1500, 'labels': ['Low Visibility', 'Moderate Visibility', 'High Visibility']}
    }

    time_of_day_columns = ['visibility_morning', 'visibility_afternoon', 'visibility_evening', 'visibility_night']
    for column in time_of_day_columns:
        if column not in data_daily.columns:
            data_daily[column] = None

    for time_of_day, params in visibility_thresholds.items():
        if time_of_day in data_daily.columns:
           low_threshold = params['low']
           high_threshold = params['high']
           low_label, medium_label, high_label = params['labels']

           data_daily[f'{time_of_day}_classification'] = np.where(
              data_daily[time_of_day] < low_threshold, low_label,
              np.where(
                  data_daily[time_of_day] > high_threshold, high_label,
                  medium_label
            )
        )



    column_order_daily = ['dt','date','time','sunrise_time','sunset_time','moonrise_time','moonset_time','moon_phase','moon_phase_classification', 'icon','pressure','pressure_classification', 'humidity','humidity_classification', 'dew_point','dew_point_classification',
                      'wind_speed','wind_speed_classification', 'wind_deg','wind_deg_classification', 'wind_gust','wind_gust_classification', 'clouds','clouds_classification', 'pop','pop_classification', 'uvi','uvi_classification','temp.day','temp.day_classification','temp.min','temp.min_classification','temp.max','temp.max_classification','temp.night','temp.night_classification', 'temp.eve','temp.eve_classification', 'temp.morn','temp.morn_classification',
                      'feels_like.day' ,'feels_like.day_classification','feels_like.night','feels_like.night_classification','feels_like.eve','feels_like.eve_classification','feels_like.morn','feels_like.morn_classification','visibility_morning','visibility_morning_classification','visibility_afternoon','visibility_afternoon_classification','visibility_evening','visibility_evening_classification','visibility_night','visibility_night_classification', 'rain','condition','weather']
#runs the program for extra column comes up with null value to written zero
    for col in column_order_daily:
        if col not in data_daily.columns:
           data_daily[col] = 0

#code adds up if any extra column shows up
    data_daily = data_daily[column_order_daily+[col for col in data_daily if col not in column_order_daily]]




    # data_daily.drop(columns=['dt'],inplace=True)
    data_daily.fillna(0,inplace=True)
    # data_daily.drop(columns=['temp','feels_like','visibility','rain.1h'],inplace=True)



    return data_daily


def push_to_mongodb(data,collection_name,collection):
    data.reset_index(drop=True,inplace=True)
    records = data.to_dict(orient='records')
    collection.insert_many(records)



def main_loop():
  hourly_collection,daily_collection=connect_to_mogodb()
  hourly_data=scraping_hourly_data()
  daily_data=scraping_daily_data(hourly_data)
  iteration=0

  while True:
    if iteration%2==0:
      new_hourly_data=scraping_hourly_data()
      hourly_data=pd.concat([hourly_data,new_hourly_data]).drop_duplicates().reset_index(drop=True)
      push_to_mongodb(hourly_data,"hourly_data",hourly_collection)
    if iteration %2 == 0:
      new_daily_data=scraping_hourly_data()
      daily_data=pd.concat([daily_data,new_daily_data]).drop_duplicates().reset_index(drop=True)
      push_to_mongodb(daily_data,"daily_data",daily_collection)

    # daily_data=fill_missing_values(daily_data,hourly_data)
    push_to_mongodb(daily_data,"daily_data",daily_collection)


    time.sleep(48*3600)
    iteration+=1

main_loop()

data_hourlyy=data_hourly.to_dict(orient='records')
result=collection.insert_many(data_hourlyy)
for documentr in collection.find():
    print(documentr)

"""#scrapping data using beautifulsoup4"""

#installing beautifulsoup
!pip install beautifulsoup4 requests

#impoting request and beautifulsoup
import requests
from bs4 import BeautifulSoup

#url for scrapping
url = "https://www.irishimmigration.ie/visa-decisions/"

#headers for scrapping
headers = {
    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.0.0 Safari/537.36",
    "Accept-Language": "en-US,en;q=0.9",
}

#getting request to fetch the html content
response = requests.get(url,headers=headers)

#html raw data to beautiful soup object
soup=BeautifulSoup(response.text,'html.parser')

#getting all rows with tr tags
rows = soup.find_all('tr')

#extracting data from each rows and columns
# chatgpt
data = []
for row in rows:
    cols = row.find_all('td')
    row_data = [col.text.strip() for col in cols]
    if row_data:
        data.append(row_data)

import pandas as pd

df = pd.DataFrame(data)

df

#changing index 0,1,2 to names
name=['number','status','nothing']

#converting the name
df.columns=name

df

#dropping nothing because there is no usable data
df.drop(columns=['nothing'],inplace=True)

df

#droping row from 1 to 14 ,no useful data
df.drop(df.index[0:15],axis=0,inplace=True)

df

#resetting row intex to 1 t0 ...
df.reset_index(drop=True,inplace=True)
df.index = df.index + 1

df